    注意: 这个地址的GC 是不保证是实际GC的,GC有多种不同实现,用什么GC是用户的自由.
   --这就是产生了一些疑问了?
        怎么查看应用程序的GC选型?
        怎么选择GC?
        常见的GC有那些?
        是否存在GC的最佳实际?

    前置知识:
        GC 解决的本质问题是什么? 识别 和 清理 动态内存分配.
        
        动态内存分配器面临的问题和需要考虑的因素包含:
            内存碎片(Fragmcntaion) 
                    指一个系统中存在大量不可用的空闲内存.
            数据对齐

            内存管理颗粒的局部性


        什么是动态内存分配?
            

文档使用范围:
    go 1.19 
   参考地址:
        https://go.dev/doc/gc-guide
    意义:
        帮助我们理解理解应用程序的开销.
        指导用户如何通过调整垃圾收集器来提高应用资源利用率.

    前提假设:
        1.你没了解过GC算法
        2.你熟悉GO语言
        
    背景:
        1.go 语言负责给go value 分配储存空间,大部分GO程序员不需要关系 这些value存在哪?以及为什么这样存.
        
        2.但是,在实际使用中,这些值存在实际的物理内存中,内存是有实际容量的,所以有内存用爆的风险,简单点
            说GC 有点参数还是要我们开发者自己来调整的.
    
    GO语言垃圾收集器(自动回收内存器):
            1.简单定义:  帮助应用程序回收内存的程序.
            2.应用程序之间的关系: GO 标准工具链提供一个随每个应用程序一起提供的运行时库,该运行时库包含一个垃圾收集器.
              (好像 是一对一的关系)
    
    现在就开始关注大部分程序员不关注的问题,
    
        那些纳入GC管理范围的 GO Value 存 在哪里?

        GC 不管理的东西:
            1.保存在非指针的GO value --又 lexical scope (又词法区域) 创建.
                -- 这种分配内存的模式就叫 栈分配,比GC快,编译器用完就清理.
                -- 这种value storge在 goroutine stack 上.
            
            2.    
         
