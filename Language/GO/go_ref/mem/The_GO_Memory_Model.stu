   核心建议:
        1.程序修改的数据将被多个goroutine(用户态线程) 同时访问的使用
          必须通过序列化访问
        2. 使用序列化访问时,请通过channel 操作或者其他 同步原语(如sync 和 sync/atom包中元语)来保护数据.
        
        3.别耍小聪明

   GO 语言内存模型:
        
        简括:
            go的内存模型和其他语言的也差不多.
        
        它的目标是:
            1.保持语义简洁
            2.易学易用
        
        一些通用概念:
            data race(数据竞争): --不想竞争对数据的操作权,就加同步锁
                如果data 没有加上 同步原语 的保护, 那么它的内存位置是可以被同时被多个线程读写.
                
            如果没有数据竞争,go 程序就是全部跑在一个 处理器上,每个线程顺序一致的复用,一个cpu.
            
            go 希望程序员尽可能写 非竞争数据的代码,因为go对数据竞争的场景支持有限.

        go 内存模型的正式定义:
            设计参考了:  Hans-J. Boehm and Sarita V. Adve in  "Foundations of the C++ Concurrency Memory Model"
            百度了一下: 大概意思好像是说 只要保证 写出来的 程序 是 符合 Data Race free要求的代码就可以实现
                        多处理器共享内存的效果,但是根据 这个doc 说的 不要自以为是,我们按照建议来用就行.
-------------------------------------------------------------------------------------------------------------
      1.程序修改的数据将被多个goroutine(用户态线程) 同时访问的使用
          必须通过序列化访问
        2. 使用序列化访问时,请通过channel 操作或者其他 同步原语(如sync 和 sync/atom包中元语)来保护数据.
        
        3.别耍小聪明
--------------------------------------------------------------------------------------------------------------



            


